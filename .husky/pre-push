#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# OS Detection
IS_WINDOWS=false
IS_WSL=false
IS_TOOLBOX=false
IS_MACOS=false
IS_LINUX=false

# Detect Windows (including Git Bash)
case "$(uname -s)" in
  CYGWIN*|MINGW*|MSYS*)
    IS_WINDOWS=true
    ;;
  Linux*)
    IS_LINUX=true
    # Check for WSL
    if grep -q Microsoft /proc/version 2>/dev/null; then
      IS_WSL=true
    fi
    # Check for Toolbox
    if [ -f /run/.toolboxenv ]; then
      IS_TOOLBOX=true
    fi
    ;;
  Darwin*)
    IS_MACOS=true
    ;;
esac

# Check if terminal supports colors
HAS_COLOR_SUPPORT=false
if [ -t 1 ]; then
  # Check for NO_COLOR environment variable (industry standard)
  if [ -z "$NO_COLOR" ]; then
    # Check for color support using tput if available
    if command -v tput >/dev/null 2>&1; then
      if [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then
        HAS_COLOR_SUPPORT=true
      fi
    else
      # Fallback check - assume color support for most modern terminals
      HAS_COLOR_SUPPORT=true
    fi
  fi
fi

# ANSI color codes using \x1b which is more portable
# These work in both Windows and Unix environments
ESC="\x1b"
RESET="${ESC}[0m"
BOLD="${ESC}[1m"
RED="${ESC}[31m"
GREEN="${ESC}[32m"
YELLOW="${ESC}[33m"
BLUE="${ESC}[34m"
MAGENTA="${ESC}[35m"
CYAN="${ESC}[36m"
WHITE="${ESC}[37m"
BRIGHT_RED="${ESC}[91m"
BRIGHT_GREEN="${ESC}[92m"
BRIGHT_YELLOW="${ESC}[93m"
BRIGHT_BLUE="${ESC}[94m"
BRIGHT_MAGENTA="${ESC}[95m"
BRIGHT_CYAN="${ESC}[96m"
BRIGHT_WHITE="${ESC}[97m"

# Function to print colorful messages with printf (more portable than echo -e)
print_message() {
  local color_name=$1
  local emoji=$2
  local message=$3
  local color_code=""

  # Set color based on name
  case $color_name in
    "red") color_code=$RED ;;
    "green") color_code=$GREEN ;;
    "yellow") color_code=$YELLOW ;;
    "blue") color_code=$BLUE ;;
    "magenta") color_code=$MAGENTA ;;
    "cyan") color_code=$CYAN ;;
    "bright_red") color_code=$BRIGHT_RED ;;
    "bright_green") color_code=$BRIGHT_GREEN ;;
    "bright_yellow") color_code=$BRIGHT_YELLOW ;;
    "bright_blue") color_code=$BRIGHT_BLUE ;;
    "bright_magenta") color_code=$BRIGHT_MAGENTA ;;
    "bright_cyan") color_code=$BRIGHT_CYAN ;;
    *) color_code=$RESET ;;
  esac

  # Use colors only if supported
  if [ "$HAS_COLOR_SUPPORT" = true ]; then
    printf "${color_code}%s %s${RESET}\n" "$emoji" "$message"
  else
    # Fallback for terminals without color support
    printf "%s %s\n" "$emoji" "$message"
  fi
}

# Function to handle errors and exit
handle_error() {
  local message=$1
  print_message "bright_red" "❌" "$message"
  print_message "yellow" "🔍" "Fix the issues before pushing again."
  exit 1
}

# Print OS information
printf "🚀 ${BRIGHT_CYAN}Starting pre-push checks...${RESET}\n"

if [ "$IS_WINDOWS" = true ]; then
  print_message "blue" "🪟" "Running on Windows"
elif [ "$IS_WSL" = true ]; then
  print_message "blue" "🐧" "Running on WSL (Windows Subsystem for Linux)"
elif [ "$IS_MACOS" = true ]; then
  print_message "blue" "🍎" "Running on macOS"
elif [ "$IS_TOOLBOX" = true ]; then
  print_message "blue" "🧰" "Running in Toolbox environment"
else
  print_message "blue" "🐧" "Running on Linux"
fi

# Start timer (cross-platform way)
if command -v perl >/dev/null 2>&1; then
  # Use perl for high-precision timing if available
  start_time=$(perl -MTime::HiRes=time -e 'printf "%.0f\n", time()*1000')
  timer_unit="ms"
  timer_divisor=1000
else
  # Fallback to date +%s (Unix timestamp in seconds)
  start_time=$(date +%s)
  timer_unit="s"
  timer_divisor=1
fi

# Check for uncommitted changes
print_message "bright_blue" "🔍" "Checking for uncommitted changes..."
if ! git diff --exit-code --quiet; then
  handle_error "You have uncommitted changes. Please commit or stash them before pushing."
fi

# Check if npm is available (cross-platform way)
NPM_AVAILABLE=false
if command -v npm >/dev/null 2>&1; then
  NPM_AVAILABLE=true
  print_message "bright_green" "✓" "npm is available, will run all checks"
else
  print_message "yellow" "⚠️" "npm command not found. Skipping npm-based checks."
fi

# Determine the correct path separator based on OS
PATH_SEP="/"
if [ "$IS_WINDOWS" = true ] && [ "$IS_WSL" = false ]; then
  # Use backslash for native Windows (but not for WSL)
  PATH_SEP="\\"
fi

# Run linting checks if npm is available
if [ "$NPM_AVAILABLE" = true ]; then
  # Run ESLint on frontend
  print_message "bright_blue" "🔍" "Running ESLint on frontend..."
  cd frontend || handle_error "Frontend directory not found!"
  if ! npm run lint --silent; then
    handle_error "ESLint found issues in frontend code. Please fix them before pushing."
  fi

  # Return to root directory
  cd ..

  # Run ESLint on backend (if it exists)
  if [ -d "backend" ]; then
    print_message "bright_blue" "🔍" "Running ESLint on backend..."
    cd backend || handle_error "Backend directory not found!"
    if ! npm run lint --silent; then
      handle_error "ESLint found issues in backend code. Please fix them before pushing."
    fi
    cd ..
  else
    print_message "yellow" "⚠️" "Backend directory not found, skipping backend linting."
  fi

  # Run Prettier check
  print_message "bright_blue" "🔍" "Checking code formatting with Prettier..."
  if ! npm run format:check --silent; then
    handle_error "Prettier found formatting issues. Run 'npm run format' to fix them."
  fi

  # Run TypeScript type checking
  print_message "bright_blue" "🔍" "Running TypeScript type checking..."
  cd frontend || handle_error "Frontend directory not found!"
  if ! npx tsc --noEmit; then
    handle_error "TypeScript found type errors. Please fix them before pushing."
  fi
  cd ..

  # Run tests (if available)
  print_message "bright_blue" "🧪" "Running tests..."
  cd frontend || handle_error "Frontend directory not found!"
  npm test --silent || print_message "yellow" "⚠️" "Tests failed or not available, but continuing..."
  cd ..
else
  print_message "yellow" "⚠️" "Skipping all npm-based checks."
fi

# Calculate execution time (cross-platform way)
if command -v perl >/dev/null 2>&1; then
  end_time=$(perl -MTime::HiRes=time -e 'printf "%.0f\n", time()*1000')
else
  end_time=$(date +%s)
fi

execution_time=$(( (end_time - start_time) / timer_divisor ))

# All checks passed
print_message "bright_green" "✅" "All pre-push checks passed successfully in ${execution_time}${timer_unit}!"
print_message "bright_green" "🚀" "Pushing to remote repository..."

# Add a separator line for better visibility
if [ "$HAS_COLOR_SUPPORT" = true ]; then
  printf "${BRIGHT_CYAN}════════════════════════════════════════════════════════════════${RESET}\n"
else
  printf "════════════════════════════════════════════════════════════════\n"
fi

exit 0
