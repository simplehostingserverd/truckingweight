/**
 * Copyright (c) 2025 Cargo Scale Pro Inc. All Rights Reserved.
 *
 * PROPRIETARY AND CONFIDENTIAL
 *
 * This file is part of the Cargo Scale Pro Inc Weight Management System.
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 *
 * This file contains proprietary and confidential information of
 * Cargo Scale Pro Inc and may not be copied, distributed, or used
 * in any way without explicit written permission.
 */

/**
 * Script to apply city schema to the database
 * This script reads the city schema file and applies it to the database
 */

const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Initialize Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_KEY
);

/**
 * Read the city schema file
 * @returns {string} - Schema SQL
 */
function readCitySchema() {
  try {
    // Try to read from prisma schema first
    const prismaSchemaPath = path.join(__dirname, '../prisma/schema_city_updates.prisma');
    if (fs.existsSync(prismaSchemaPath)) {
      console.log('Reading city schema from Prisma file...');
      const prismaSchema = fs.readFileSync(prismaSchemaPath, 'utf8');
      return convertPrismaToSQL(prismaSchema);
    }

    // Fall back to SQL file if it exists
    const sqlSchemaPath = path.join(__dirname, '../sql/city_schema.sql');
    if (fs.existsSync(sqlSchemaPath)) {
      console.log('Reading city schema from SQL file...');
      return fs.readFileSync(sqlSchemaPath, 'utf8');
    }

    throw new Error('City schema file not found');
  } catch (error) {
    console.error('Error reading city schema:', error);
    process.exit(1);
  }
}

/**
 * Convert Prisma schema to SQL
 * This is a simplified conversion for demonstration
 * In a production environment, use prisma migrate
 * @param {string} prismaSchema - Prisma schema
 * @returns {string} - SQL schema
 */
function convertPrismaToSQL(prismaSchema) {
  console.log('Converting Prisma schema to SQL...');

  // Extract model definitions
  const modelRegex = /model\s+(\w+)\s+{([^}]*)}/g;
  let sql = '';
  let match;

  while ((match = modelRegex.exec(prismaSchema)) !== null) {
    const tableName = match[1];
    const tableContent = match[2];

    // Start creating table
    sql += `-- Table: ${tableName}\n`;
    sql += `CREATE TABLE IF NOT EXISTS ${tableName} (\n`;

    // Parse fields
    const lines = tableContent.trim().split('\n');
    const fields = [];
    const constraints = [];

    for (const line of lines) {
      const trimmedLine = line.trim();

      // Skip comments and empty lines
      if (trimmedLine.startsWith('//') || trimmedLine === '') {
        continue;
      }

      // Check if it's a relation
      if (trimmedLine.includes('@relation')) {
        // Extract foreign key constraint
        const relationMatch = trimmedLine.match(
          /(\w+)\s+(\w+).*@relation\(fields:\s*\[(\w+)\],\s*references:\s*\[(\w+)\]/
        );
        if (relationMatch) {
          const [, relatedType /* fieldName */, , localField, foreignField] = relationMatch;
          constraints.push(
            `FOREIGN KEY (${localField}) REFERENCES ${relatedType}(${foreignField})`
          );
        }
        continue;
      }

      // Parse regular field
      const fieldMatch = trimmedLine.match(
        /(\w+)\s+(\w+)(\??)(\s+@id)?(\s+@default\(([^)]+)\))?(\s+@db\.(\w+)(\(([^)]+)\))?)?/
      );
      if (fieldMatch) {
        const [, fieldName, fieldType, optional, isId, , defaultValue, , dbType, , dbTypeParams] =
          fieldMatch;

        let sqlType = mapPrismaTypeToSQL(fieldType, dbType, dbTypeParams);
        let constraints = [];

        // Add primary key constraint
        if (isId) {
          constraints.push('PRIMARY KEY');
        }

        // Add NOT NULL constraint
        if (!optional) {
          constraints.push('NOT NULL');
        }

        // Add default value
        if (defaultValue) {
          if (defaultValue === 'autoincrement()') {
            if (sqlType.includes('INT')) {
              constraints.push('GENERATED BY DEFAULT AS IDENTITY');
            }
          } else if (defaultValue === 'now()') {
            constraints.push('DEFAULT CURRENT_TIMESTAMP');
          } else if (defaultValue === 'uuid()') {
            constraints.push('DEFAULT gen_random_uuid()');
          } else {
            constraints.push(`DEFAULT ${defaultValue}`);
          }
        }

        fields.push(`  ${fieldName} ${sqlType} ${constraints.join(' ')}`);
      }
    }

    // Add all fields and constraints
    sql += fields.join(',\n');

    // Add table constraints
    if (constraints.length > 0) {
      sql += ',\n  ' + constraints.join(',\n  ');
    }

    sql += '\n);\n\n';
  }

  return sql;
}

/**
 * Map Prisma types to SQL types
 * @param {string} prismaType - Prisma type
 * @param {string} dbType - Database type annotation
 * @param {string} dbTypeParams - Database type parameters
 * @returns {string} - SQL type
 */
function mapPrismaTypeToSQL(prismaType, dbType, dbTypeParams) {
  if (dbType) {
    // Use explicit DB type if provided
    let type = dbType.toUpperCase();
    if (dbTypeParams) {
      type += `(${dbTypeParams})`;
    }
    return type;
  }

  // Map Prisma types to SQL types
  switch (prismaType) {
    case 'String':
      return 'VARCHAR(255)';
    case 'Int':
      return 'INTEGER';
    case 'Float':
      return 'REAL';
    case 'Boolean':
      return 'BOOLEAN';
    case 'DateTime':
      return 'TIMESTAMP WITH TIME ZONE';
    case 'Decimal':
      return 'DECIMAL(10, 2)';
    case 'Json':
      return 'JSONB';
    default:
      return 'TEXT';
  }
}

/**
 * Apply schema to database
 * @param {string} schema - SQL schema
 */
async function applySchema(schema) {
  try {
    console.log('Applying schema to database...');

    // Split schema into individual statements
    const statements = schema.split(';').filter(stmt => stmt.trim() !== '');

    for (const statement of statements) {
      const { error } = await supabase.rpc('exec_sql', { sql: statement + ';' });

      if (error) {
        console.error('Error executing SQL:', error);
        console.error('Statement:', statement);
      }
    }

    console.log('Schema applied successfully');
  } catch (error) {
    console.error('Error applying schema:', error);
    process.exit(1);
  }
}

/**
 * Main function
 */
async function main() {
  try {
    const schema = readCitySchema();
    await applySchema(schema);
    process.exit(0);
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

// Run the script
main();
